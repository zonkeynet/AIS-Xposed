<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitoraggio Navale Europa</title>
    <!-- Caricamento di Tailwind CSS per lo stile -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Caricamento di Leaflet CSS per la mappa -->
    <!-- RIMOSSO ATTRIBUTI INTEGRITY E CROSSORIGIN PER RISOLVERE ERRORE DI CARICAMENTO SRI -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        /* Stili personalizzati per il layout */
        #map {
            height: 100vh;
            width: 100%;
        }
        .vessel-card {
            cursor: pointer;
            transition: transform 0.1s ease-in-out;
        }
        .vessel-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>
<body class="bg-gray-50 flex h-screen overflow-hidden font-sans">

    <!-- Pannello Laterale per Filtri e Lista Navi -->
    <div id="sidebar" class="w-full md:w-80 flex-shrink-0 bg-white shadow-xl p-4 overflow-y-auto z-10">
        <h1 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-2">Monitoraggio Marittimo</h1>
        <p id="connectionStatus" class="text-xs font-semibold mb-3 p-1 rounded text-yellow-800 bg-yellow-100">
            Connessione al Worker in corso...
        </p>

        <!-- Sezione Filtri -->
        <div id="filters" class="mb-6 p-4 bg-gray-50 rounded-lg border">
            <h2 class="text-lg font-semibold text-gray-700 mb-3">Filtri Categoria</h2>
            <div class="space-y-2">
                <label class="flex items-center text-sm font-medium text-gray-600">
                    <input type="checkbox" id="filterMilitary" onchange="applyFilters()" class="form-checkbox h-4 w-4 text-red-600 rounded">
                    <span class="ml-2">Navi Militari (Rosso)</span>
                </label>
                <label class="flex items-center text-sm font-medium text-gray-600">
                    <input type="checkbox" id="filterArms" onchange="applyFilters()" class="form-checkbox h-4 w-4 text-yellow-500 rounded">
                    <span class="ml-2">Trasporto Armi (Giallo)</span>
                </label>
                <label class="flex items-center text-sm font-medium text-gray-600">
                    <input type="checkbox" id="filterIsrael" onchange="applyFilters()" class="form-checkbox h-4 w-4 text-blue-600 rounded">
                    <span class="ml-2">Correlate a Israele (Blu)</span>
                </label>
            </div>
            <div class="mt-4">
                <label for="destinationPort" class="block text-sm font-medium text-gray-700 mb-1">Porto di Destinazione:</label>
                <input type="text" id="destinationPort" oninput="applyFilters()" placeholder="Es: Livorno, Genova..." class="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 text-sm">
            </div>
        </div>

        <!-- Sezione Lista Navi -->
        <h2 class="text-xl font-bold text-gray-800 mb-3">Lista Navi (<span id="vesselCount">0</span>)</h2>
        <div id="vesselList" class="space-y-3">
            <!-- Le schede delle navi verranno inserite qui -->
            <p class="text-center text-gray-500">Nessuna nave corrispondente ai filtri.</p>
        </div>
    </div>

    <!-- Area Mappa -->
    <div id="map" class="flex-grow"></div>

    <!-- Caricamento di Leaflet JS -->
    <!-- RIMOSSO ATTRIBUTI INTEGRITY E CROSSORIGIN PER RISOLVERE ERRORE DI CARICAMENTO SRI -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // === SETUP ENVIRONMENT AND INITIALIZATIONS ===
        // Costanti globali fornite dall'ambiente
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let map;
        let vesselData = []; // Array per memorizzare i dati AIS in tempo reale
        let markerLayer = new L.LayerGroup();
        let ws; // Variabile per la connessione WebSocket

        // Dati fittizi per simulare il flusso in arrivo dal Worker (solo come fallback)
        const SIMULATED_STREAM_DATA = [
            { id: "215880000", name: "Zim Livorno", type: "Container", military: false, arms: false, destination: "Livorno, IT", is_israel_related: true, lat: 43.1, lon: 10.0, status: "En Route", mmsi: "215880000" },
            { id: "235112000", name: "HMS Aegis", type: "Destroyer", military: true, arms: true, destination: "Piraeus, GR", is_israel_related: false, lat: 40.5, lon: 20.5, status: "En Route", mmsi: "235112000" },
        ];

        // Mappa dei colori per i marcatori
        const COLOR_MAP = {
            military: '#D90000', // Rosso scuro
            arms: '#FFD700',     // Oro/Giallo
            israel: '#0047AB',   // Blu profondo
            default: '#22C55E'   // Verde
        };

        // Funzione per ottenere l'icona del marcatore
        function getMarkerIcon(vessel) {
            let color = COLOR_MAP.default;

            // Priorità: Militare > Armi > Israele
            if (vessel.military) {
                color = COLOR_MAP.military; 
            } else if (vessel.arms) {
                color = COLOR_MAP.arms; 
            } else if (vessel.is_israel_related) {
                color = COLOR_MAP.israel; 
            }

            // Icona Nave (basata sul geo-punto)
            const svgContent = `
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <!-- Forma di nave semplificata -->
                    <path d="M12 2L6 22H18L12 2Z" fill="${color}" stroke="#FFF" stroke-width="1.5" stroke-linejoin="round"/>
                </svg>`;

            return L.divIcon({
                className: 'custom-marker',
                html: svgContent,
                iconSize: [24, 24],
                iconAnchor: [12, 12], // Centrato per la forma triangolare
                popupAnchor: [0, -12]
            });
        }

        // Funzione per disegnare o aggiornare i marcatori sulla mappa
        function renderMapMarkers(vessels) {
            markerLayer.clearLayers();

            vessels.forEach(vessel => {
                const icon = getMarkerIcon(vessel);
                const marker = L.marker([vessel.lat, vessel.lon], { icon: icon })
                    .bindPopup(`
                        <strong class="text-lg">${vessel.name}</strong><br>
                        Tipo: ${vessel.type}<br>
                        Destinazione: <strong>${vessel.destination}</strong><br>
                        Stato: ${vessel.status}<br>
                        ${vessel.military ? '<span class="text-red-600 font-bold">MILITARE</span><br>' : ''}
                        ${vessel.arms ? '<span class="text-yellow-600 font-bold">TRASPORTO ARMI</span><br>' : ''}
                        ${vessel.is_israel_related ? '<span class="text-blue-600 font-bold">CORRELATA ISRAELE</span><br>' : ''}
                    `);
                
                marker.addTo(markerLayer);
                vessel.marker = marker; // Collega il marcatore all'oggetto nave
            });

            if (!map.hasLayer(markerLayer)) {
                markerLayer.addTo(map);
            }
        }

        // Funzione per aggiornare la lista laterale
        function renderVesselList(vessels) {
            const listContainer = document.getElementById('vesselList');
            const countElement = document.getElementById('vesselCount');
            listContainer.innerHTML = ''; // Svuota la lista
            countElement.textContent = vessels.length;

            if (vessels.length === 0) {
                listContainer.innerHTML = '<p class="text-center text-gray-500 py-4">Nessuna nave trovata con questi filtri.</p>';
                return;
            }

            vessels.forEach(vessel => {
                const badgeClass = vessel.military ? 'bg-red-100 text-red-800' : 
                                   vessel.arms ? 'bg-yellow-100 text-yellow-800' : 
                                   vessel.is_israel_related ? 'bg-blue-100 text-blue-800' : 
                                   'bg-green-100 text-green-800';

                const card = document.createElement('div');
                card.className = "vessel-card p-3 rounded-lg bg-white shadow border border-gray-200 hover:border-indigo-400";
                card.innerHTML = `
                    <p class="text-sm font-bold text-gray-800">${vessel.name || 'Nome Sconosciuto'}</p>
                    <p class="text-xs text-gray-600 truncate">Dest: ${vessel.destination || 'N/A'}</p>
                    <span class="inline-block text-xs font-semibold px-2 py-0.5 mt-1 rounded-full ${badgeClass}">
                        ${vessel.military ? 'Militare' : vessel.arms ? 'Armi' : vessel.is_israel_related ? 'Israel' : 'Generica'}
                    </span>
                `;
                
                // Funzionalità: cliccando sulla card, la mappa si centra sul marcatore
                card.onclick = () => {
                    if (vessel.marker) {
                        map.setView([vessel.lat, vessel.lon], 10);
                        vessel.marker.openPopup();
                    }
                };

                listContainer.appendChild(card);
            });
        }

        // Funzione per elaborare un messaggio AIS in arrivo (già pre-filtrato dal Worker)
        function handleIncomingVesselMessage(vesselUpdate) {
            // LOG DI DEBUG: Verifica che il dato venga ricevuto dalla logica
            console.log("Dato nave ricevuto/aggiornato:", vesselUpdate.name, "Lat:", vesselUpdate.lat, "Lon:", vesselUpdate.lon);
            
            // L'ID univoco è l'MMSI
            const existingIndex = vesselData.findIndex(v => v.id === vesselUpdate.id);
            
            if (!vesselUpdate.lat || !vesselUpdate.lon) {
                // Se mancano coordinate, è un messaggio di metadati o fuori area
                return; 
            }

            if (existingIndex !== -1) {
                // AGGIORNA: La nave è già nella lista. Aggiorna solo posizione e stato.
                vesselData[existingIndex] = { 
                    ...vesselData[existingIndex], 
                    ...vesselUpdate,
                    name: vesselData[existingIndex].name || vesselUpdate.name,
                    destination: vesselData[existingIndex].destination || vesselUpdate.destination
                };
            } else {
                // NUOVA NAVE: Aggiungila se ha i dati essenziali
                vesselData.push(vesselUpdate);
            }

            // Riapplica i filtri per aggiornare la mappa e la lista in tempo reale
            applyFilters();
        }


        // SIMULAZIONE DEL FLUSSO DI DATI (sostituisce la connessione WS per l'ambiente sandboxed)
        let streamIndex = 0;
        function simulateStreamingData() {
            if (streamIndex < SIMULATED_STREAM_DATA.length) {
                handleIncomingVesselMessage(SIMULATED_STREAM_DATA[streamIndex]);
                streamIndex++;
            } else if (streamIndex === SIMULATED_STREAM_DATA.length) {
                console.log("Simulazione: Fine del flusso dati iniziale.");
                streamIndex++;
                return;
            }
            
            // Continua a inviare il prossimo pacchetto (se disponibile) ogni 1 secondo
            if (streamIndex < SIMULATED_STREAM_DATA.length + 1) {
                 setTimeout(simulateStreamingData, 1000); 
            }
        }

        // Funzione per stabilire la connessione WebSocket al Cloudflare Worker
        function connectWebSocket() {
            // Usiamo l'indirizzo del tuo Worker
            const workerUrl = `wss://trackwarships.zonkeynet.workers.dev/api/vessels`; 
            
            try {
                // Tentativo di connessione WebSocket
                ws = new WebSocket(workerUrl);
            
                ws.onopen = () => {
                    document.getElementById('connectionStatus').textContent = "Connessione Worker Cloudflare: ATTIVA";
                    document.getElementById('connectionStatus').classList.replace('bg-yellow-100', 'bg-green-100');
                    document.getElementById('connectionStatus').classList.replace('text-yellow-800', 'text-green-800');
                    console.log('Connessione WebSocket stabilita con il Worker Cloudflare.');
                };

                ws.onmessage = (event) => {
                    // Si assume che il Worker invii messaggi JSON già filtrati
                    const message = JSON.parse(event.data);
                    handleIncomingVesselMessage(message);
                };

                ws.onclose = (event) => {
                    console.log('Connessione WebSocket chiusa. Tentativo di riconnessione in 5s...');
                    document.getElementById('connectionStatus').textContent = "Connessione chiusa. Riconnessione in 5s...";
                    document.getElementById('connectionStatus').classList.replace('bg-green-100', 'bg-red-100');
                    document.getElementById('connectionStatus').classList.replace('text-green-800', 'text-red-800');
                    setTimeout(connectWebSocket, 5000); 
                };

                ws.onerror = (error) => {
                    console.error('Errore WebSocket:', error);
                    document.getElementById('connectionStatus').textContent = "Errore di Connessione. Uso Fallback.";
                    document.getElementById('connectionStatus').classList.replace('bg-green-100', 'bg-red-100');
                    document.getElementById('connectionStatus').classList.replace('text-green-800', 'text-red-800');
                    // In caso di errore, avviamo il fallback con i dati simulati
                    console.log("ATTENZIONE: Avvio della SIMULAZIONE dati a causa di un errore WebSocket."); // LOG DI DEBUG
                    simulateStreamingData();
                };

            } catch (error) {
                // Fallback: se la WS fallisce (es. ambiente restrittivo)
                console.warn("WebSocket non avviato (errore nel browser o ambiente). Avvio simulazione dati.");
                document.getElementById('connectionStatus').textContent = "Simulazione dati AIS in corso...";
                console.log("ATTENZIONE: Avvio della SIMULAZIONE dati a causa di un errore Catch JS."); // LOG DI DEBUG
                simulateStreamingData();
            }
        }


        // Funzione principale per applicare i filtri sul dato locale
        function applyFilters() {
            const filterMilitary = document.getElementById('filterMilitary').checked;
            const filterArms = document.getElementById('filterArms').checked;
            const filterIsrael = document.getElementById('filterIsrael').checked;
            const destinationPort = document.getElementById('destinationPort').value.toLowerCase().trim();

            const filteredVessels = vesselData.filter(vessel => {
                // Filtro Categoria
                const isAnyFilterChecked = filterMilitary || filterArms || filterIsrael;
                let matchesCategory = true;
                
                if (isAnyFilterChecked) {
                    matchesCategory = (filterMilitary && vessel.military) ||
                                      (filterArms && vessel.arms) ||
                                      (filterIsrael && vessel.is_israel_related);
                }
                
                // Filtro Destinazione
                let matchesDestination = true;
                if (destinationPort) {
                    matchesDestination = (vessel.destination || '').toLowerCase().includes(destinationPort);
                }

                return matchesCategory && matchesDestination;
            });

            renderMapMarkers(filteredVessels);
            renderVesselList(filteredVessels);
        }

        // Funzione che avvia la connessione al Worker
        async function fetchVesselData() {
            connectWebSocket(); 
        }

        // Funzione di inizializzazione
        function initMap() {
            // Inizializza la mappa centrata sul Mediterraneo
            map = L.map('map').setView([38.0, 15.0], 5);

            // Aggiunge un livello di mappa (Tile Layer)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Avvia il caricamento dei dati (o la connessione al Worker)
            fetchVesselData();
        }

        // Avvia l'app al caricamento della finestra
        window.onload = initMap;
    </script>
</body>
</html>
